[18/06/2014 - 20h50 - GMT -3]
I've been running into several bumps and walls during the 
coding of the Travelling Salesman for the Savanna GA Stack. 
The modeling of the Dna for this particular problem is not
even close to be considered usual.
The main problem resides in the way the possible routes are
mapped into the Dna and the consequent complications on the
mutation and mainly the crossover operation.
The first challenge is how to create valid routes.
Each route must contain only one occurrence of each city, but
also needs to contain all the possible cities. So (Todo 1) We 
might want to have a route validator method.
The second important thing to have is a efficient way of storing
the map for the problem. It's important to notice that the
path from A to B must have the same cost of the path from B to A.
Inconsistencies of such nature will cause flaws in the process, 
hence is vital to (Todo 2) have a map validator method.
I believe that the calculator of cost for a given route is fine,
like the methods to compare two possible routes. We should be 
okay on those.
Also, the mutation concept is fine, but it must be generalized
for any possible number of nodes (right now it works only for
4 cities). So (Todo 3) we need to refactor the mutation method.
The Factory is not implemented yet. (Todo 4) The generate method
needs to be coded following the simple idea of starting from 
city A, and then picking randomly each next city, respecting the
basic rule of never repeating the city and making sure it passes
through all the cities.
The greatest challenge so far is the concept for crossover. I've
drafted a concept for it, although I am not sure if it covers the
needs. The basic idea is poorly represented on the following notes:

Cities & Distances
(1)
  A B C D E F G
A - 2 2 4 5 8 5 
B 2 - 8 3 8 1 5
C 2 8 - 7 2 2 1 
D 4 3 7 - 1 4 4
E 5 8 2 1 - 5 2
F 8 1 2 4 5 - 3
G 5 5 1 4 2 3 -

(2)
  A B C D E F G H I J K L M N O P Q R S T
A - 1 2 4 5 8 1 2 1 7 9 2 4 2 7 9 2 3 4 2
B 1 - 1 3 8 2 5 3 2 5 7 1 3 2 9 4 2 3 4 1
C 2 1 - 1 2 2 1 8 4 3 6 7 2 1 8 6 7 2 3 5
D 4 3 1 - 1 4 4 3 2 5 6 2 8 6 3 2 5 4 7 2
E 5 8 2 1 - 1 2 4 7 3 2 1 7 6 3 2 7 2 2 4
F 8 2 2 4 1 - 1 8 3 2 1 4 6 8 2 3 5 3 2 9
G 1 5 1 4 2 1 - 1 2 7 2 1 5 3 2 9 2 1 4 5
H 2 3 8 3 4 8 1 - 1 2 8 9 1 2 3 2 8 4 3 2
I 1 2 4 2 7 3 2 1 - 1 2 3 2 4 6 8 2 2 1 6
J 7 5 3 5 3 2 7 2 1 - 1 4 8 3 2 3 6 2 6 7 
K 9 7 6 6 2 1 2 8 2 1 - 1 4 5 6 2 9 3 2 8
L 2 1 7 2 1 4 1 9 3 4 1 - 1 2 1 6 5 3 8 2
M 4 3 2 8 7 6 5 1 2 8 4 1 - 1 2 5 3 4 2 8
N 2 2 1 6 6 8 3 2 4 3 5 2 1 - 1 3 2 6 7 9
O 7 9 8 3 3 2 2 3 6 2 6 1 2 1 - 1 9 7 4 3 
P 9 4 6 2 2 3 9 2 8 3 2 6 5 3 1 - 1 4 2 7
Q 2 2 7 5 7 5 2 8 2 6 9 5 3 2 9 1 - 1 3 6 
R 3 3 2 4 2 3 1 4 2 2 3 3 4 6 7 4 1 - 1 8
S 4 4 3 7 2 2 4 3 1 6 2 8 2 7 4 2 3 1 - 1
T 2 1 5 2 4 9 5 2 6 7 8 2 8 9 3 7 6 8 1 -

(1)
King - A C G B F D E A -> 2 + 1 + 5 + 1 + 4 + 1 + 5 = 19 cost
Lion - A B E C G D F A -> 2 + 8 + 2 + 1 + 4 + 4 + 8 = 29 cost

(2)
King - A C G B F D E A -> 2 + 1 + 5 + 2 + 4 + 1 + 5 = 20 cost
Lion - A B E C G D F A -> 1 + 8 + 2 + 1 + 4 + 4 + 8 = 28 cost

1) Finds the "move" from King with lower cost, that isn't present on Lion
2) Replaces that move in Lion, making the changes to keep the route valid

In this example, we would have this solution as a cub:
(1) Cub - A B F C G D E A -> 2 + 1 + 2 + 1 + 4 + 1 + 5 = 16
(2) Cub - A B F C G D E A -> 1 + 2 + 2 + 1 + 4 + 1 + 5 = 16


(Todo 5) Yeah, this needs to be implemented. Also, (Todo 6) the operation
described above needs to be encapsulated so we can reproduce it as
many times as we need in a single crossover operation.

[19/06/2014 - 11h13 - GMT -3]
Alright, so I was never a huge fan of the way I was storing the maps.
Today I came up with an idea: instead of emulating a matrix with
a HashMap inside of a HashMap (my main goal here was to have the key->value
pair capability) I could just have a "one-dimension" hash that would store
the costs of each movement between cities (i.e. "AB" => 3, "BC"=> 3).
This might be a pain to code, but will definitely be more efficient.
Also, since the map is becoming a little creature by itself, I probably
should turn it into a separate class. Then the checkMap method should be moved
to there. So (Todo 2) now becomes creating the Map class, implementing the
new method for keeping the info about the distances and allowing the
call of checkMap map method (ok, Todo 2.1 and Todo 2.2). 

[19/06/2014 - 17h46 - GMT -3]
(Todo 2) The Map class and the map validator are done.

[20/06/2014 - 12h14 - GMT -3]
(Todo 3) The mutation operator and (Todo 4) The Factory are implemented.
However, for now they are not prepared to deal with any kinds of maps. The whole
code is being prepared focusing for now only on the specific map listed above, with
minor changes so we know for sure the best solution for it, for tests purposes.
After we succeed in the first test, I wanna go back to these methods and prepare
them to solve a map of any size. Let's move to (Todo 5) and (Todo 6) now.

[20/06/2014 - 17h00 - GMT -3]
Ok, so we have pretty much everything implemented, (Todo 5 and 6) are done, but 
the crossover operation is still very glitchy. I need to break it down and 
refactor it using unit testing. 

[21/06/2014 - 10h34 - GMT -3]
Yesterday I got a lot of progress on the Travelling Salesman class (and its derivatives).
However, and I consider myself guilty, there is a certain lack of documentation. Like
no documentation. And it's becoming a mess. I need to stop now and organize all this
code. The bug is on the crossover method, that's for sure. Ok, that's not totally sure.
So I guess the first thing would be making sure of this. (Todo 7) I need to isolate
this bug, so I will replace the crossover operation for something really simple and 
test the program again. I need to get to a point where there is no bugs at all. I am
hoping the glitch is gone after I do it and then I am gonna be sure the problem resides
on the crossover method. (Todo 8) I need to document the TravellingSalesman, 
TravellingSalesmanFactory and TravellingSalesmanMap classes. That includes also reviewing
each method and making sure I need it that way. I don't want to spend lots of time
refactoring now, but if I can improve the code fast, I guess it wont hurt to make
little changes. Then the most important, (Todo 9) I need to solve this bug. The best 
approach is to abstract some of the steps to other methods, so the code gets simpler,
and this way I can do the development with unit testing. I bet the main reason
this bug appeared was cause I let myself go and wrote a bunch of stuff without making
unit testing. Let's go back then and be more loyal to the TDD philosophy. After that the
code will be ready to receive some cool extensions, like the creating maps automatically.
I wanna test the GA with 20 or 25 cities.

[21/06/2014 - 11h30 - GMT -3]
Good news! I've accomplished (Todo 7), isolating the crossover method. 
Then I runned the program hundreds of times and had no bug at all. The problem is 
on that method, for sure. Time to organized all the code before refactoring
this chunk.
 
[22/06/2014 - 10h27 - GMT -3]
So, we had lots of things going on since yesterday. I've fixed that first bug
and the GA is running much more smooth now. However, there are still two bugs.
One is quite frequent and has to do with the fact that sometimes the crossover
can't find its shortest move that is not on its mate. An empty string is returned
and I get a OutOfBoundException. The other problem, much less frequent, is generating
invalid routes. I am beat on this one for now. Need further testing.
 
[22/06/2014 - 23h03 - GMT -3]
Ok, so I managed to fix the bug in the crossover. It was kinda a pain in the ass
to find it. It was happening to a very particular scenario and due to the fact
that lots of things in the algorithm are randomized, it's hard to create tests
to find the bug. Although I must admit that part of the bug was being caused
but two embasarrassing  mistakes I've made. Basically, I was trying to duplicate
data structure objects via direct assignment. So I was chaning stuff I shouldn't
touch. Anyways, it's fixed. Now I still need to deal with crossover when the
two Dna's involved are the same (I will call that Todo 10) and I need to organized
everything. I am sure there is lots to refactor code, looking for more efficient
or organized ways of doing stuff (Todo 11). Overall I am satisfied with the base of the
Genetic Algorithm, cause I barely had to touch it.   

[23/06/2014 - 10h11 - GMT -3]
The TravellingSalesman problem is finally done and with no bugs. Most of the time,
running the GA finds the best solution in less than 100 generations. A few times
the search get stuck in a local minor. I believe this can be solved with
adjustments on the mutation operation. Anyways, I need to organize the code
a little better now, improve documentation, make it more efficient, but I feel
I could try a bigger map at this point. Let's see what I can do about that
before moving on.

 


