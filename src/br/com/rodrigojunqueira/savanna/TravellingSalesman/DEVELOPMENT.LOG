[18/06/2014 - 20h50 - GMT -3]
I've been running into several bumps and walls during the 
coding of the Travelling Salesman for the Savanna GA Stack. 
The modeling of the Dna for this particular problem is not
even close to be considered usual.
The main problem resides in the way the possible routes are
mapped into the Dna and the consequent complications on the
mutation and mainly the crossover operation.
The first challenge is how to create valid routes.
Each route must contain only one occurrence of each city, but
also needs to contain all the possible cities. So (Todo 1) We 
might want to have a route validator method.
The second important thing to have is a efficient way of storing
the map for the problem. It's important to notice that the
path from A to B must have the same cost of the path from B to A.
Inconsistencies of such nature will cause flaws in the process, 
hence is vital to (Todo 2) have a map validator method.
I believe that the calculator of cost for a given route is fine,
like the methods to compare two possible routes. We should be 
okay on those.
Also, the mutation concept is fine, but it must be generalized
for any possible number of nodes (right now it works only for
4 cities). So (Todo 3) we need to refactor the mutation method.
The Factory is not implemented yet. (Todo 4) The generate method
needs to be coded following the simple idea of starting from 
city A, and then picking randomly each next city, respecting the
basic rule of never repeating the city and making sure it passes
through all the cities.
The greatest challenge so far is the concept for crossover. I've
drafted a concept for it, although I am not sure if it covers the
needs. The basic idea is poorly represented on the following notes:

Cities & Distances
(1)
  A B C D E F G
A - 2 2 4 5 8 5 
B 2 - 8 3 8 1 5
C 2 8 - 7 2 2 1 
D 4 3 7 - 1 4 4
E 5 8 2 1 - 5 2
F 8 1 2 4 5 - 3
G 5 5 1 4 2 3 -

(2)
  A B C D E F G
A - 1 2 4 5 8 1 
B 1 - 1 3 8 2 5
C 2 1 - 1 2 2 1 
D 4 3 1 - 1 4 4
E 5 8 2 1 - 1 2
F 8 2 2 4 1 - 1
G 1 5 1 4 2 1 -

(1)
King - A C G B F D E A -> 2 + 1 + 5 + 1 + 4 + 1 + 5 = 19 cost
Lion - A B E C G D F A -> 2 + 8 + 2 + 1 + 4 + 4 + 8 = 29 cost

(2)
King - A C G B F D E A -> 2 + 1 + 5 + 2 + 4 + 1 + 5 = 20 cost
Lion - A B E C G D F A -> 1 + 8 + 2 + 1 + 4 + 4 + 8 = 28 cost

1) Finds the "move" from King with lower cost, that isn't present on Lion
2) Replaces that move in Lion, making the changes to keep the route valid

In this example, we would have this solution as a cub:
(1) Cub - A B F C G D E A -> 2 + 1 + 2 + 1 + 4 + 1 + 5 = 16
(2) Cub - A B F C G D E A -> 1 + 2 + 2 + 1 + 4 + 1 + 5 = 16


(Todo 5) Yeah, this needs to be implemented. Also, (Todo 6) the operation
described above needs to be encapsulated so we can reproduce it as
many times as we need in a single crossover operation.



[19/06/2014 - 11h13 - GMT -3]
Alright, so I was never a huge fan of the way I was storing the maps.
Today I came up with an idea: instead of emulating a matrix with
a HashMap inside of a HashMap (my main goal here was to have the key->value
pair capability) I could just have a "one-dimension" hash that would store
the costs of each movement between cities (i.e. "AB" => 3, "BC"=> 3).
This might be a pain to code, but will definitely be more efficient.
Also, since the map is becoming a little creature by itself, I probably
should turn it into a separate class. Then the checkMap method should be moved
to there. So (Todo 2) now becomes creating the Map class, implementing the
new method for keeping the info about the distances and allowing the
call of checkMap map method (ok, Todo 2.1 and Todo 2.2). 

[19/06/2014 - 17h46 - GMT -3]
(Todo 2) The Map class and the map validator are done.

[20/06/2014 - 12h14 - GMT -3]
(Todo 3) The mutation operator and (Todo 4) The Factory are implemented.
However, for now they are not prepared to deal with any kinds of maps. The whole
code is being prepared focusing for now only on the specific map listed above, with
minor changes so we know for sure the best solution for it, for tests purposes.
After we succeed in the first test, I wanna go back to these methods and prepare
them to solve a map of any size. Let's move to (Todo 5) and (Todo 6) now.



 


